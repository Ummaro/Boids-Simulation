<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Boids Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            width: 100%; height: 100%; overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a2e;
        }
        
        canvas {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: block;
        }
        
        .controls-panel {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(10px);
            padding: 15px 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            z-index: 100;
            max-height: 40vh;
            overflow-y: auto;
            transition: transform 0.3s ease;
        }
        
        .controls-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .controls-header-left {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .stats {
            display: flex;
            gap: 20px;
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.85em;
        }
        
        .stat span:first-child {
            opacity: 0.6;
        }
        
        button {
            padding: 8px 20px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: white;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: bold;
            transition: all 0.2s ease;
        }
        button:hover {
            background: rgba(255, 255, 255, 0.25);
        }
        
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-size: 0.9em;
            cursor: pointer;
        }
        .checkbox-wrapper input {
            width: 16px; height: 16px;
            cursor: pointer;
        }
        
        .sliders-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px 20px;
        }
        
        .slider-group {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.8em;
        }
        
        .slider-value {
            color: #4da6ff;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            height: 4px;
            cursor: pointer;
            accent-color: #4da6ff;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="controls-panel" id="controls-panel">
        <div class="controls-header">
            <div class="controls-header-left">
                <button id="pause-btn">Pause</button>
                <label class="checkbox-wrapper">
                    <input type="checkbox" id="wrap_mode" checked>
                    <span>Wrap Mode</span>
                </label>
            </div>
            <div class="stats">
                <div class="stat"><span>Boids:</span> <span id="boid-count">0</span></div>
                <div class="stat"><span>FPS:</span> <span id="fps">0</span></div>
                <div class="stat"><span>Frame:</span> <span id="frame">0</span></div>
            </div>
        </div>
        
        <div class="sliders-grid">
            <div class="slider-group">
                <div class="slider-label">
                    <span>Boid Count</span>
                    <span class="slider-value" id="boidcount-val">750</span>
                </div>
                <input type="range" id="boid_count" min="0" max="5000" step="10" value="750">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Pulling Strength</span>
                    <span class="slider-value" id="strength-val">0.15</span>
                </div>
                <input type="range" id="strength" min="0" max="1" step="0.01" value="0.15">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Range of View</span>
                    <span class="slider-value" id="range-val">3</span>
                </div>
                <input type="range" id="range_of_view" min="2" max="50" step="1" value="3">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Max Velocity</span>
                    <span class="slider-value" id="maxvel-val">1.50</span>
                </div>
                <input type="range" id="max_velocity" min="0.0" max="10" step="0.1" value="1.5">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Min Velocity</span>
                    <span class="slider-value" id="minvel-val">0.50</span>
                </div>
                <input type="range" id="min_velocity" min="0" max="10" step="0.1" value="0.5">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Randomness</span>
                    <span class="slider-value" id="random-val">0.25</span>
                </div>
                <input type="range" id="random_factor" min="0" max="1" step="0.05" value="0.25">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Repulsion</span>
                    <span class="slider-value" id="repulsion-val">0.03</span>
                </div>
                <input type="range" id="repulsion_factor" min="0" max="1" step="0.01" value="0.03">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Slowdown Isolated Strength</span>
                    <span class="slider-value" id="slow-val">0.01</span>
                </div>
                <input type="range" id="slow_factor" min="0" max="1" step="0.01" value="0.01">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Desagregation Strength</span>
                    <span class="slider-value" id="confusion-val">0.15</span>
                </div>
                <input type="range" id="confusion_factor" min="0" max="1" step="0.05" value="0.15">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Outer Boid Weakness</span>
                    <span class="slider-value" id="distance-val">0.05</span>
                </div>
                <input type="range" id="distance_factor" min="0" max="1" step="0.05" value="0.05">
            </div>
            <div class="slider-group">
                <div class="slider-label">
                    <span>Boid Size</span>
                    <span class="slider-value" id="size-val">4.00</span>
                </div>
                <input type="range" id="default_size" min="0.5" max="10" step="0.5" value="4">
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // ===== Activity Tracking =====
        const ACTIVITY_ENDPOINT = 'https://portfolio.ummaro.fr/api/projects/boids/activity';
        const RESET_ENDPOINT = 'https://portfolio.ummaro.fr/api/projects/boids/reset';
        
        async function trackActivity() {
            try {
                fetch(ACTIVITY_ENDPOINT, { method: 'POST' }).catch(() => {});
            } catch (e) {}
        }
        
        // Track activity on any input
        document.addEventListener('input', trackActivity, true);
        document.addEventListener('change', trackActivity, true);
        
        // Track initial page load
        trackActivity();
        
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let lastUpdateTime = Date.now();
        let frameCount = 0, fps = 0;
        
        let gridX1 = 100, gridY1 = 100, gridX2 = -100, gridY2 = -100;
        let boidsData = { b: [], f: 0, p: false };
        
        let minVelocity = 0.5;
        let maxVelocity = 1.5;
        
        function getColorForVelocity(velocity) {
            const clamped = Math.max(minVelocity, Math.min(maxVelocity, velocity));
            const normalized = (maxVelocity > minVelocity) ? (clamped - minVelocity) / (maxVelocity - minVelocity) : 0;
            
            const coldR = 100, coldG = 200, coldB = 255;
            const warmR = 255, warmG = 100, warmB = 50;
            
            const r = Math.round(coldR + (warmR - coldR) * normalized);
            const g = Math.round(coldG + (warmG - coldG) * normalized);
            const b = Math.round(coldB + (warmB - coldB) * normalized);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        function worldToScreen(x, y) {
            const sx = ((x - gridX2) / (gridX1 - gridX2)) * canvas.width;
            const sy = canvas.height - ((y - gridY2) / (gridY1 - gridY2)) * canvas.height;
            return { sx, sy };
        }
        
        function drawArrow(fromX, fromY, toX, toY, size) {
            const headlen = size * 2;
            const angle = Math.atan2(toY - fromY, toX - fromX);
            
            ctx.beginPath();
            ctx.moveTo(fromX, fromY);
            ctx.lineTo(toX, toY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(toX, toY);
            ctx.lineTo(toX - headlen * Math.cos(angle - Math.PI / 6), toY - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(toX - headlen * Math.cos(angle + Math.PI / 6), toY - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }
        
        function draw() {
            ctx.fillStyle = 'rgb(26, 26, 46)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.lineWidth = 2;
            
            if (boidsData && boidsData.b && Array.isArray(boidsData.b)) {
                for (const boid of boidsData.b) {
                    const screen = worldToScreen(boid[0], boid[1]);
                    const actualVelocity = Math.sqrt(boid[2] * boid[2] + boid[3] * boid[3]);
                    const size = boid[4] || 3;
                    
                    const scaleFactor = size / 3;
                    const vx = boid[2] * 5 * scaleFactor;
                    const vy = -boid[3] * 5 * scaleFactor;
                    
                    const color = getColorForVelocity(actualVelocity);
                    ctx.strokeStyle = color;
                    ctx.fillStyle = color;
                    
                    if (actualVelocity > 0.1) {
                        drawArrow(screen.sx, screen.sy, screen.sx + vx, screen.sy + vy, size);
                    } else {
                        ctx.beginPath();
                        ctx.arc(screen.sx, screen.sy, size, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
            
            document.getElementById('frame').textContent = boidsData.f || 0;
            document.getElementById('boid-count').textContent = (boidsData.b && boidsData.b.length) || 0;
            
            frameCount++;
            const now = Date.now();
            if (now - lastUpdateTime >= 1000) {
                fps = frameCount;
                frameCount = 0;
                lastUpdateTime = now;
                document.getElementById('fps').textContent = fps;
            }
        }
        
        function animate() {
            draw();
            requestAnimationFrame(animate);
        }
        
        // Connect to Socket.IO - use explicit URL for proxy support
        const socketUrl = 'https://' + window.location.hostname;
        console.log('Socket.IO URL:', socketUrl);
        const socket = io(socketUrl, {
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000,
            reconnectionAttempts: 5,
            transports: ['websocket', 'polling']
        });
        
        socket.on('connect', () => {
            console.log('Connected to server');
        });
        
        socket.on('connect_error', (error) => {
            console.error('Connection error:', error);
        });
        
        socket.on('disconnect', (reason) => {
            console.warn('Disconnected:', reason);
        });
        
        socket.on('init', (data) => {
            if (data.grid_x1 !== undefined) {
                gridX1 = data.grid_x1;
                gridY1 = data.grid_y1;
                gridX2 = data.grid_x2;
                gridY2 = data.grid_y2;
            }
            if (data.max_velocity !== undefined) {
                maxVelocity = data.max_velocity;
                minVelocity = data.min_velocity;
                document.getElementById('max_velocity').value = data.max_velocity;
                document.getElementById('maxvel-val').textContent = data.max_velocity.toFixed(2);
                document.getElementById('min_velocity').value = data.min_velocity;
                document.getElementById('minvel-val').textContent = data.min_velocity.toFixed(2);
            }
            if (data.boid_count !== undefined) {
                document.getElementById('boid_count').value = data.boid_count;
                document.getElementById('boidcount-val').textContent = data.boid_count;
            }
        });
        
        socket.on('boids', (data) => {
            boidsData = data;
        });
        
        socket.on('paused', (isPaused) => {
            document.getElementById('pause-btn').textContent = isPaused ? 'Resume' : 'Pause';
        });
        
        document.getElementById('pause-btn').addEventListener('click', () => {
            socket.emit('pause');
        });
        
        // Parameter sliders
        const params = ['strength', 'range_of_view', 'random_factor', 'max_velocity', 'min_velocity', 'repulsion_factor', 'slow_factor', 'confusion_factor', 'distance_factor', 'default_size'];
        const paramLabels = {
            'strength': 'strength-val',
            'range_of_view': 'range-val',
            'random_factor': 'random-val',
            'max_velocity': 'maxvel-val',
            'min_velocity': 'minvel-val',
            'repulsion_factor': 'repulsion-val',
            'slow_factor': 'slow-val',
            'confusion_factor': 'confusion-val',
            'distance_factor': 'distance-val',
            'default_size': 'size-val'
        };
        
        params.forEach(param => {
            const slider = document.getElementById(param);
            const label = document.getElementById(paramLabels[param]);
            
            slider.addEventListener('input', (e) => {
                const value = parseFloat(e.target.value);
                label.textContent = param === 'range_of_view' ? value : value.toFixed(2);
                socket.emit('update_param', { param: param, value: value });
                trackActivity();  // Track this interaction
                
                if (param === 'max_velocity') maxVelocity = value;
                if (param === 'min_velocity') minVelocity = value;
            });
        });
        
        // Boid count slider
        const boidCountSlider = document.getElementById('boid_count');
        const boidCountLabel = document.getElementById('boidcount-val');
        boidCountSlider.addEventListener('input', (e) => {
            const count = parseInt(e.target.value);
            boidCountLabel.textContent = count;
            socket.emit('set_boid_count', { count: count });
            trackActivity();  // Track this interaction
        });
        
        // Wrap mode checkbox
        const wrapModeCheckbox = document.getElementById('wrap_mode');
        wrapModeCheckbox.addEventListener('change', (e) => {
            socket.emit('update_param', { param: 'wrap_mode', value: e.target.checked });
            trackActivity();  // Track this interaction
        });
        
        animate();
    </script>
</body>
</html>
